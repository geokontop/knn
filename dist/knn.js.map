{"version":3,"sources":["../src/knn.js"],"names":["path","require","knn","getNeighbors","dataSet","testInstance","except","k","callback","distances","x","dist","euclideanDistance","push","distListed","sort","a","b","classify","slice","data1","data2","distance","field","indexOf","Math","pow","sqrt","neighbors","classVotes","neighbor","type","sortable","getAccuracy","testSet","fieldType","correct","wrong","res","module","exports"],"mappings":"AAAA;;;;;AAKC;AACD,IAAIA,OAAOC,QAAQ,WAAR,CAAX;;AAEA;AACA,MAAMC,MAAM,EAAZ;;AAEA;AACAA,IAAIC,YAAJ,GAAmB,CAACC,OAAD,EAAUC,YAAV,EAAwBC,MAAxB,EAAgCC,CAAhC,EAAmCC,QAAnC,KAA8C;AAC7DC,gBAAY,EAAZ;AACA;AACA,SAAI,IAAIC,CAAR,IAAaN,OAAb,EAAqB;AACjBO,eAAOT,IAAIU,iBAAJ,CAAsBP,YAAtB,EAAoCD,QAAQM,CAAR,CAApC,EAAgDJ,MAAhD,CAAP;AACAG,kBAAUI,IAAV,CAAe,EAACT,SAAQA,QAAQM,CAAR,CAAT,EAAqBC,MAAMA,IAA3B,EAAf;AACH;AACD,UAAMG,aAAaL,UAAUM,IAAV,CAAe,UAASC,CAAT,EAAYC,CAAZ,EAAe;AAC7C,eAAOD,EAAEL,IAAF,GAASM,EAAEN,IAAlB;AACH,KAFkB,CAAnB;;AAIAH,aAASN,IAAIgB,QAAJ,CAAaJ,WAAWK,KAAX,CAAiB,CAAjB,EAAmBZ,CAAnB,CAAb,CAAT;AAEH,CAbD;;AAeA;AACAL,IAAIU,iBAAJ,GAAsB,CAACQ,KAAD,EAAQC,KAAR,EAAcf,MAAd,KAAuB;AACzC,QAAIgB,WAAW,CAAf;AACA,SAAI,IAAIC,KAAR,IAAiBH,KAAjB,EAAuB;AACnB,YAAGd,OAAOkB,OAAP,CAAeD,KAAf,MAAwB,CAAC,CAA5B,EAA8B;AAC1BD,wBAAYG,KAAKC,GAAL,CAAUN,MAAMG,KAAN,IAAaF,MAAME,KAAN,CAAvB,EAAqC,CAArC,CAAZ;AACH;AACJ;AACD,WAAOE,KAAKE,IAAL,CAAUL,QAAV,CAAP;AACH,CARD;;AAUApB,IAAIgB,QAAJ,GAAcU,SAAD,IAAa;AACtBC,iBAAa,EAAb;AACA,SAAI,IAAIC,QAAR,IAAoBF,SAApB,EAA8B;AAC1B,YAAGC,WAAWC,SAAS1B,OAAT,CAAiB2B,IAA5B,CAAH,EAAqC;AACjCF,uBAAWC,SAAS1B,OAAT,CAAiB2B,IAA5B,KAAqC,CAArC;AACH,SAFD,MAEK;AACDF,uBAAWC,SAAS1B,OAAT,CAAiB2B,IAA5B,IAAoC,CAApC;AACH;AACJ;AACD,UAAMC,WAAW,EAAjB;AACA,SAAK,IAAID,IAAT,IAAiBF,UAAjB,EAA6B;AACzBG,iBAASnB,IAAT,CAAc,CAACkB,IAAD,EAAOF,WAAWE,IAAX,CAAP,CAAd;AACH;;AAEDC,aAASjB,IAAT,CAAc,UAASC,CAAT,EAAYC,CAAZ,EAAe;AACzB,eAAOA,EAAE,CAAF,IAAOD,EAAE,CAAF,CAAd;AACH,KAFD;AAGA,WAAOgB,SAAS,CAAT,EAAY,CAAZ,CAAP;AACH,CAlBD;;AAoBA9B,IAAI+B,WAAJ,GAAgB,CAAC7B,OAAD,EAAU8B,OAAV,EAAmB5B,MAAnB,EAA2BC,CAA3B,EAA8B4B,SAA9B,EAAyC3B,QAAzC,KAAoD;AAChE4B,cAAU,CAAV;AACAC,YAAO,CAAP;AACA,SAAI,IAAIhC,YAAR,IAAwB6B,OAAxB,EAAgC;AAC5BhC,YAAIC,YAAJ,CAAiBC,OAAjB,EAA0BC,YAA1B,EAAwCC,MAAxC,EAAgDC,CAAhD,EAAoD+B,GAAD,IAAO;AACtD,gBAAGA,QAAMjC,aAAa8B,SAAb,CAAT,EAAiC;AAC7BC,2BAAW,CAAX;AACH,aAFD,MAEK;AACDC,yBAAS,CAAT;AACH;AACJ,SAND;AAQH;AACD7B,aAAS,MAAI4B,OAAJ,IAAaA,UAAQC,KAArB,CAAT;AACH,CAdD;;AAgBAE,OAAOC,OAAP,GAAiBtC,GAAjB","file":"knn.js","sourcesContent":["/*\r\n * Getting the data from a csv file, forming datasets, evaluating distances\r\n * \r\n */\r\n\r\n // Dependencies\r\nvar path = require('./helpers');\r\n\r\n// Container\r\nconst knn = {};\r\n\r\n// Get k neighbors in the training sample\r\nknn.getNeighbors = (dataSet, testInstance, except, k, callback)=>{\r\n    distances = []\r\n    // length =\r\n    for(let x in dataSet){\r\n        dist = knn.euclideanDistance(testInstance, dataSet[x], except);\r\n        distances.push({dataSet:dataSet[x], dist: dist})        \r\n    }\r\n    const distListed = distances.sort(function(a, b) {\r\n        return a.dist - b.dist;\r\n    });\r\n    \r\n    callback(knn.classify(distListed.slice(0,k)));\r\n    \r\n}\r\n\r\n// Evaluate Euclidean distance\r\nknn.euclideanDistance=(data1, data2,except)=>{\r\n    let distance = 0;\r\n    for(let field in data1){\r\n        if(except.indexOf(field)===-1){\r\n            distance += Math.pow((data1[field]-data2[field]),2);\r\n        }        \r\n    }\r\n    return Math.sqrt(distance);\r\n}\r\n\r\nknn.classify=(neighbors)=>{\r\n    classVotes = {};\r\n    for(let neighbor of neighbors){\r\n        if(classVotes[neighbor.dataSet.type]){\r\n            classVotes[neighbor.dataSet.type] += 1;\r\n        }else{\r\n            classVotes[neighbor.dataSet.type] = 1;\r\n        }\r\n    }\r\n    const sortable = [];\r\n    for (var type in classVotes) {\r\n        sortable.push([type, classVotes[type]]);\r\n    }\r\n\r\n    sortable.sort(function(a, b) {\r\n        return b[1] - a[1];\r\n    });\r\n    return sortable[0][0];\r\n}\r\n\r\nknn.getAccuracy=(dataSet, testSet, except, k, fieldType, callback)=>{\r\n    correct = 0;\r\n    wrong =0;\r\n    for(let testInstance of testSet){\r\n        knn.getNeighbors(dataSet, testInstance, except, k, (res)=>{\r\n            if(res===testInstance[fieldType]){\r\n                correct += 1;\r\n            }else{\r\n                wrong += 1;\r\n            }\r\n        });\r\n\r\n    }\r\n    callback(100*correct/(correct+wrong))\r\n}\r\n\r\nmodule.exports = knn;"]}